#include <iostream>
#include <string>
using namespace std;

/*
Фабричный метод (Factory Method) — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса.
В момент создания наследники могут определить, какой класс инстанциировать. Иными словами, фабрика делегирует создание объектов наследникам родительского класса.
Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.
Фабричный метод  определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанциировать.

Применимость:
-	классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
-	класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.
-	класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс принимает эти обязанности на себя.

Достоинство:
Фабричные методы избавляют проектировщика от необходимости встраивать в код зависящие от приложения классы. Код имеет дело только с интерфейсом
класса Product, поэтому он может работать с любыми определенными пользователями классами конкретных продуктов.
Недостаток:
Потенциальный недостаток фабричного метода состоит в том, что клиентам, возможно, придется создавать подкласс класса Creator для создания лишь одного объекта ConcreteProduct.
*/

//продукт (PC) определяет интерфейс объектов, создаваемых фабричным методом
class Product abstract
{

public:
	virtual void doStuff() = 0;

};

// Конкретный продукт реализует интерфейс Product (в нашем случае, PC)
class ProductA : public Product
{
public:
	
	void doStuff() {
		cout << "Product A is created";
	}
};

class ProductB : public Product
{
public:

	void doStuff() {
		cout << "Product B is created";
	}
};


// Конкретный продукт реализует интерфейс Product (в нашем случае, PC)



// создатель объявляет фабричный метод, возвращающий объект типа Product.
class Creator abstract
{
public:
	virtual Product* FactoryMethod() = 0;
};

// конкретный создатель переопределяет фабричный метод, возвращающий объект ConcreteProduct.
class CreatorA: public Creator
{
public:
	Product* FactoryMethod()override
	{
		Product* a = new ProductA();
		a->doStuff();
		return a;
	}
};

class CreatorB : public Creator
{
public:
	Product* FactoryMethod()override
	{
		Product* a = new ProductB();
		a->doStuff();
		return a;
	}
};


void main()
{

}